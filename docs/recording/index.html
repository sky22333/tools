<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Recorder Studio</title>
    
    <!-- Polyfill for process -->
    <script>
        window.process = { env: { NODE_ENV: 'production' } };
    </script>
    
    <!-- React & ReactDOM -->
    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
        tailwind.config = {
            darkMode: 'class',
            theme: {
                extend: {
                    colors: {
                        slate: { 850: '#1e293b', 900: '#0f172a', 950: '#020617' }
                    },
                    animation: {
                        'fade-in': 'fadeIn 0.3s ease-out',
                        'slide-up': 'slideUp 0.4s cubic-bezier(0.16, 1, 0.3, 1)'
                    },
                    keyframes: {
                        fadeIn: { '0%': { opacity: '0' }, '100%': { opacity: '1' } },
                        slideUp: { '0%': { transform: 'translateY(20px)', opacity: '0' }, '100%': { transform: 'translateY(0)', opacity: '1' } }
                    }
                }
            }
        }
    </script>

    <!-- Icons -->
    <script src="https://unpkg.com/lucide@latest"></script>
    
    <!-- Video Processing -->
    <script src="https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.0/build/mp4-muxer.min.js"></script>

    <!-- ByteMD -->
    <link rel="stylesheet" href="https://unpkg.com/bytemd@1.21.0/dist/index.min.css">
    <script src="https://unpkg.com/bytemd@1.21.0/dist/index.umd.js"></script>
    
    <style>
        /* Custom Scrollbar */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: transparent; }
        ::-webkit-scrollbar-thumb { background: #cbd5e1; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #94a3b8; }
        .dark ::-webkit-scrollbar-thumb { background: #475569; }
        .dark ::-webkit-scrollbar-thumb:hover { background: #64748b; }

        /* Range Input */
        input[type=range] { -webkit-appearance: none; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: #0f172a; margin-top: -6px; box-shadow: 0 1px 3px rgba(0,0,0,0.3); transition: transform 0.1s; cursor: pointer; }
        .dark input[type=range]::-webkit-slider-thumb { background: #f8fafc; box-shadow: 0 1px 3px rgba(0,0,0,0.5); }
        input[type=range]::-webkit-slider-thumb:hover { transform: scale(1.2); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; background: #e2e8f0; border-radius: 2px; }
        .dark input[type=range]::-webkit-slider-runnable-track { background: #334155; }

        /* ByteMD Customization */
        .bytemd { height: 100% !important; border: none !important; }
        .bytemd-toolbar { border-bottom: 1px solid #f1f5f9 !important; background-color: #f8fafc !important; padding: 0 12px !important; }
        .bytemd-body { background-color: #ffffff; }
        
        /* ByteMD Dark Mode Override */
        .dark .bytemd-toolbar { border-bottom: 1px solid #334155 !important; background-color: #1e293b !important; color: #e2e8f0 !important; }
        .dark .bytemd-toolbar-icon { color: #e2e8f0 !important; }
        .dark .bytemd-toolbar-icon:hover { background-color: #334155 !important; }
        .dark .bytemd-body { background-color: #0f172a !important; color: #e2e8f0 !important; }
        .dark .markdown-body { color: #e2e8f0 !important; }
    </style>
</head>
<body class="bg-gray-50 text-slate-900 overflow-hidden">
    <div id="root"></div>

    <script type="text/babel">
        const { useState, useEffect, useRef, useMemo, useCallback } = React;
        const { Video, Mic, Monitor, Settings, X, Download, Play, Pause, Plus, Trash2, ChevronLeft, Search, Edit2, Eye, FileText, MoreHorizontal, Moon, Sun, Github } = (typeof lucide !== 'undefined' && lucide.icons) ? lucide.icons : lucide;
        // Fix Mp4Muxer reference
        const Mp4Muxer = window.Mp4Muxer;

        // --- UI Components ---

        const Icon = ({ icon, size = 20, className = "" }) => {
            const ref = useRef(null);
            useEffect(() => {
                if (ref.current && icon) {
                    ref.current.innerHTML = '';
                    try {
                        if (typeof lucide !== 'undefined' && lucide.createElement) {
                            const svg = lucide.createElement(icon);
                            svg.setAttribute('width', size);
                            svg.setAttribute('height', size);
                            if (className) {
                                const existingClass = svg.getAttribute('class') || '';
                                svg.setAttribute('class', (existingClass + ' ' + className).trim());
                            }
                            ref.current.appendChild(svg);
                        } else if (Array.isArray(icon)) {
                             const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
                             svg.setAttribute('width', size);
                             svg.setAttribute('height', size);
                             svg.setAttribute('viewBox', '0 0 24 24');
                             svg.setAttribute('fill', 'none');
                             svg.setAttribute('stroke', 'currentColor');
                             svg.setAttribute('stroke-width', '2');
                             svg.setAttribute('stroke-linecap', 'round');
                             svg.setAttribute('stroke-linejoin', 'round');
                             if (className) svg.setAttribute('class', className);
                             icon.forEach(([tag, attrs]) => {
                                 const el = document.createElementNS('http://www.w3.org/2000/svg', tag);
                                 Object.entries(attrs || {}).forEach(([k, v]) => el.setAttribute(k, v));
                                 svg.appendChild(el);
                             });
                             ref.current.appendChild(svg);
                        } else if (typeof icon.toSvg === 'function') {
                             const svg = icon.toSvg({ class: className, width: size, height: size });
                             ref.current.innerHTML = svg;
                        }
                    } catch (e) { console.error("Icon render error", e); }
                }
            }, [icon, size, className]);
            return <span ref={ref} className="flex items-center justify-center" />;
        };

        const Button = ({ children, onClick, variant = 'primary', className = '', icon, disabled = false }) => {
            const baseStyle = "inline-flex items-center justify-center gap-2 px-4 py-2 rounded-lg font-medium transition-all duration-200 disabled:opacity-50 disabled:cursor-not-allowed focus:outline-none focus:ring-2 focus:ring-offset-1";
            const variants = {
                primary: "bg-slate-900 text-white hover:bg-slate-800 shadow-lg shadow-slate-900/20 focus:ring-slate-900 dark:bg-slate-700 dark:hover:bg-slate-600 dark:shadow-slate-900/40",
                secondary: "bg-white text-slate-700 border border-slate-200 hover:bg-slate-50 hover:border-slate-300 shadow-sm focus:ring-slate-200 dark:bg-slate-800 dark:text-slate-200 dark:border-slate-700 dark:hover:bg-slate-700",
                ghost: "text-slate-600 hover:bg-slate-100 hover:text-slate-900 dark:text-slate-400 dark:hover:bg-slate-800 dark:hover:text-white",
                danger: "bg-red-50 text-red-600 hover:bg-red-100 border border-red-100 dark:bg-red-900/20 dark:text-red-400 dark:border-red-900/30"
            };
            
            return (
                <button onClick={onClick} disabled={disabled} className={`${baseStyle} ${variants[variant]} ${className}`}>
                    {icon && <Icon icon={icon} size={18} />}
                    {children}
                </button>
            );
        };

        const Card = ({ title, children, actions, className = '', footer, noPadding = false }) => (
            <div className={`bg-white rounded-xl border border-slate-200 shadow-sm hover:shadow-md transition-all duration-300 flex flex-col overflow-hidden group ${className} dark:bg-slate-800 dark:border-slate-700`}>
                {(title || actions) && (
                    <div className="px-6 py-4 border-b border-slate-100 flex justify-between items-center bg-white/50 backdrop-blur-sm dark:border-slate-700 dark:bg-slate-800/50">
                        {title && <h3 className="font-semibold text-slate-800 text-base dark:text-white">{title}</h3>}
                        {actions && <div className="flex gap-2">{actions}</div>}
                    </div>
                )}
                <div className={`${noPadding ? '' : 'p-6'} flex-grow relative`}>{children}</div>
                {footer && (
                    <div className="px-6 py-3 border-t border-slate-100 bg-gray-50/30 flex justify-between items-center gap-3 dark:border-slate-700 dark:bg-slate-900/30">
                        {footer}
                    </div>
                )}
            </div>
        );

        const Modal = ({ isOpen, onClose, title, children }) => {
            if (!isOpen) return null;
            return (
                <div className="fixed inset-0 z-50 flex items-center justify-center p-4">
                    <div className="absolute inset-0 bg-slate-900/20 backdrop-blur-sm transition-opacity" onClick={onClose}></div>
                    <div className="bg-white rounded-2xl shadow-2xl w-full max-w-lg relative z-10 animate-slide-up border border-white/20 dark:bg-slate-800 dark:border-slate-700">
                        <div className="flex justify-between items-center p-6 border-b border-slate-100 dark:border-slate-700">
                            <h3 className="text-xl font-bold text-slate-900 dark:text-white">{title}</h3>
                            <button onClick={onClose} className="text-slate-400 hover:text-slate-600 transition-colors bg-slate-50 p-2 rounded-full hover:bg-slate-100 dark:bg-slate-700 dark:hover:bg-slate-600 dark:text-slate-300">
                                <Icon icon={X} size={20} />
                            </button>
                        </div>
                        <div className="p-6">{children}</div>
                    </div>
                </div>
            );
        };

        const Toggle = ({ label, checked, onChange }) => (
            <div className="flex items-center justify-between cursor-pointer group" onClick={() => onChange(!checked)}>
                <span className="text-sm font-medium text-slate-700 group-hover:text-slate-900 transition-colors dark:text-slate-300 dark:group-hover:text-white">{label}</span>
                <div className={`w-11 h-6 flex items-center rounded-full p-1 transition-colors duration-300 ${checked ? 'bg-slate-900 dark:bg-blue-600' : 'bg-slate-200 dark:bg-slate-700'}`}>
                    <div className={`bg-white w-4 h-4 rounded-full shadow-md transform transition-transform duration-300 ${checked ? 'translate-x-5' : ''}`}></div>
                </div>
            </div>
        );

        const Select = ({ label, value, onChange, options }) => (
            <div className="space-y-1.5">
                <label className="text-xs font-semibold text-slate-500 uppercase tracking-wider dark:text-slate-400">{label}</label>
                <div className="relative">
                    <select 
                        value={value} 
                        onChange={(e) => onChange(e.target.value)}
                        className="w-full appearance-none bg-white border border-slate-200 text-slate-900 text-sm rounded-lg focus:ring-2 focus:ring-slate-900 focus:border-slate-900 block p-2.5 transition-shadow hover:border-slate-300 dark:bg-slate-800 dark:border-slate-700 dark:text-white dark:focus:ring-slate-500 dark:focus:border-slate-500"
                    >
                        {options.map(opt => <option key={opt.value} value={opt.value}>{opt.label}</option>)}
                    </select>
                    <div className="absolute inset-y-0 right-0 flex items-center px-2 pointer-events-none text-slate-500">
                        <svg className="w-4 h-4" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M19 9l-7 7-7-7"></path></svg>
                    </div>
                </div>
            </div>
        );

        const ByteMDEditor = ({ value, onChange }) => {
            const editorRef = useRef(null);
            const instanceRef = useRef(null);

            useEffect(() => {
                if (!editorRef.current) return;
                
                const editor = new bytemd.Editor({
                    target: editorRef.current,
                    props: {
                        value: value || '',
                        locale: {
                            // Simple Chinese localization override if needed, but ByteMD defaults are English.
                            // For simplicity, we use default.
                        }
                    }
                });

                editor.$on('change', (e) => {
                    onChange(e.detail.value);
                });

                instanceRef.current = editor;

                return () => {
                    editor.$destroy();
                };
            }, []);

            useEffect(() => {
                if (instanceRef.current) {
                    instanceRef.current.$set({ value: value || '' });
                }
            }, [value]);

            return <div ref={editorRef} className="h-full w-full" />;
        };

        // --- Views ---

        const DashboardView = ({ recordings, onNewRecording, onEdit, onDelete, onPreview, isRecording }) => {
            const [searchTerm, setSearchTerm] = useState('');
            
            const filteredRecordings = recordings.filter(r => 
                r.title.toLowerCase().includes(searchTerm.toLowerCase()) || 
                r.slug.toLowerCase().includes(searchTerm.toLowerCase())
            );

            return (
                <div className="space-y-8 animate-fade-in pb-12">
                    {/* Header & Search */}
                    <div className="flex flex-col md:flex-row md:items-center justify-between gap-6">
                        <div className="relative max-w-lg w-full group">
                            <div className="absolute inset-y-0 left-0 pl-3 flex items-center pointer-events-none">
                                <Icon icon={Search} className="text-slate-400 group-focus-within:text-slate-900 transition-colors dark:text-slate-500 dark:group-focus-within:text-slate-300" />
                            </div>
                            <input 
                                type="text" 
                                placeholder="搜索录屏..." 
                                className="block w-full pl-10 pr-3 py-3 border border-slate-200 rounded-xl leading-5 bg-white placeholder-slate-400 focus:outline-none focus:ring-2 focus:ring-slate-900 focus:border-transparent sm:text-sm transition-all shadow-sm group-hover:shadow-md dark:bg-slate-800 dark:border-slate-700 dark:text-white dark:placeholder-slate-500 dark:focus:ring-slate-500"
                                value={searchTerm}
                                onChange={e => setSearchTerm(e.target.value)}
                            />
                        </div>
                        <Button onClick={onNewRecording} icon={Video} disabled={isRecording} className="shadow-lg hover:shadow-xl hover:scale-105 transition-transform py-3 px-6">
                            新建录制
                        </Button>
                    </div>

                    {/* Grid */}
                    {filteredRecordings.length === 0 ? (
                        <div className="text-center py-20 bg-white rounded-2xl border border-dashed border-slate-300 dark:bg-slate-800 dark:border-slate-700">
                            <div className="mx-auto w-16 h-16 bg-slate-50 rounded-full flex items-center justify-center mb-4 dark:bg-slate-700">
                                <Icon icon={Video} size={32} className="text-slate-300 dark:text-slate-500" />
                            </div>
                            <h3 className="text-lg font-medium text-slate-900 dark:text-white">暂无录屏内容</h3>
                            <p className="text-slate-500 mt-1 dark:text-slate-400">点击右上角按钮开始您的第一次录制</p>
                        </div>
                    ) : (
                        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                            {filteredRecordings.map(rec => (
                                <Card 
                                    key={rec.id}
                                    title={rec.title}
                                    footer={
                                        <>
                                            <div className="flex gap-1">
                                                <button onClick={() => onEdit(rec)} className="p-2 text-slate-500 hover:text-slate-900 hover:bg-slate-100 rounded-lg transition-colors dark:text-slate-400 dark:hover:text-white dark:hover:bg-slate-700" title="编辑">
                                                    <Icon icon={Edit2} size={18} />
                                                </button>
                                                <button onClick={() => onDelete(rec.id)} className="p-2 text-slate-500 hover:text-red-600 hover:bg-red-50 rounded-lg transition-colors dark:text-slate-400 dark:hover:text-red-400 dark:hover:bg-red-900/20" title="删除">
                                                    <Icon icon={Trash2} size={18} />
                                                </button>
                                            </div>
                                            <button onClick={() => onPreview(rec)} className="text-sm font-medium text-slate-600 hover:text-slate-900 px-3 py-1.5 rounded-md hover:bg-slate-100 transition-colors dark:text-slate-400 dark:hover:text-white dark:hover:bg-slate-700">
                                                预览
                                            </button>
                                        </>
                                    }
                                >
                                    <div className="space-y-4">
                                        <div className="flex items-center justify-between">
                                            <div className="flex items-center gap-2 text-xs text-slate-500 dark:text-slate-400">
                                                <Icon icon={FileText} size={14} />
                                                <span className="font-mono truncate max-w-[120px]">{rec.slug}</span>
                                            </div>
                                            {rec.status === 'draft' && (
                                                <span className="inline-flex items-center px-2.5 py-0.5 rounded-full text-xs font-medium bg-slate-100 text-slate-600 border border-slate-200 dark:bg-slate-700 dark:text-slate-300 dark:border-slate-600">
                                                    草稿
                                                </span>
                                            )}
                                        </div>
                                        <div className="aspect-video bg-slate-100 rounded-lg overflow-hidden relative group cursor-pointer border border-slate-200 dark:bg-slate-900 dark:border-slate-700" onClick={() => onPreview(rec)}>
                                            <video src={rec.url} className="w-full h-full object-cover" />
                                            <div className="absolute inset-0 bg-slate-900/0 group-hover:bg-slate-900/10 transition-colors flex items-center justify-center">
                                                <div className="w-12 h-12 bg-white/90 rounded-full flex items-center justify-center shadow-lg opacity-0 group-hover:opacity-100 transform scale-75 group-hover:scale-100 transition-all duration-300 dark:bg-slate-800/90">
                                                    <Icon icon={Play} size={20} className="text-slate-900 ml-1 dark:text-white" />
                                                </div>
                                            </div>
                                            <div className="absolute bottom-2 right-2 bg-black/60 backdrop-blur-sm text-white text-[10px] px-2 py-1 rounded-md font-mono">
                                                {rec.duration}
                                            </div>
                                        </div>
                                        <div className="flex items-center text-xs text-slate-400 gap-2">
                                            <span>{rec.date}</span>
                                            <span>•</span>
                                            <span>Video</span>
                                        </div>
                                    </div>
                                </Card>
                            ))}
                        </div>
                    )}
                </div>
            );
        };

        const EditorView = ({ recording, onBack, onSave, onExport, theme, toggleTheme }) => {
            const [activeTab, setActiveTab] = useState('editor'); // editor, notes
            const [isPlaying, setIsPlaying] = useState(false);
            const [currentTime, setCurrentTime] = useState(0);
            const [duration, setDuration] = useState(0);
            const [keyframes, setKeyframes] = useState(recording.keyframes || []);
            const [selectedKeyframeId, setSelectedKeyframeId] = useState(null);
            const [trim, setTrim] = useState(recording.trim || { start: 0, end: 0 });
            const [exportProgress, setExportProgress] = useState(0);
            const [isExporting, setIsExporting] = useState(false);
            const [markdown, setMarkdown] = useState(recording.notes || '# 视频备注\n\n在这里记录关于这个视频的笔记...');

            const videoRef = useRef(null);
            const timelineRef = useRef(null);
            const isDraggingRef = useRef(false);
            const draggingKeyframeIdRef = useRef(null);
            const draggingTrimRef = useRef(null);

            // Helpers
            const formatTime = (s) => {
                if (isNaN(s)) return "00:00";
                const m = Math.floor(s / 60).toString().padStart(2, '0');
                const sec = Math.floor(s % 60).toString().padStart(2, '0');
                return `${m}:${sec}`;
            };

            useEffect(() => {
                if (duration > 0 && trim.end === 0) {
                    setTrim(prev => ({ ...prev, end: duration }));
                }
            }, [duration]);

            const togglePlay = () => {
                if (videoRef.current) {
                    if (isPlaying) videoRef.current.pause();
                    else videoRef.current.play();
                    setIsPlaying(!isPlaying);
                }
            };

            const handleTimeUpdate = () => {
                if (videoRef.current) setCurrentTime(videoRef.current.currentTime);
            };

            // Keyframes Logic
            const addKeyframe = () => {
                const newKf = { id: Date.now(), time: currentTime, scale: 1.5, x: 0, y: 0 };
                setKeyframes(prev => [...prev, newKf].sort((a,b) => a.time - b.time));
                setSelectedKeyframeId(newKf.id);
            };
            const updateKeyframe = (id, updates) => {
                setKeyframes(prev => prev.map(kf => kf.id === id ? { ...kf, ...updates } : kf));
            };
            const deleteKeyframe = (id) => {
                setKeyframes(prev => prev.filter(kf => kf.id !== id));
                setSelectedKeyframeId(null);
            };
            const selectedKeyframe = useMemo(() => keyframes.find(k => k.id === selectedKeyframeId), [keyframes, selectedKeyframeId]);

            // Transform logic
            const currentTransform = useMemo(() => {
                if (keyframes.length === 0) return { scale: 1, x: 0, y: 0 };
                const sorted = keyframes;
                if (currentTime <= sorted[0].time) return sorted[0];
                if (currentTime >= sorted[sorted.length-1].time) return sorted[sorted.length-1];
                let prev = sorted[0], next = sorted[sorted.length-1];
                for(let i=0; i<sorted.length-1; i++) {
                    if (currentTime >= sorted[i].time && currentTime < sorted[i+1].time) {
                        prev = sorted[i]; next = sorted[i+1]; break;
                    }
                }
                const ratio = (currentTime - prev.time) / (next.time - prev.time);
                return {
                    scale: prev.scale + (next.scale - prev.scale) * ratio,
                    x: prev.x + (next.x - prev.x) * ratio,
                    y: prev.y + (next.y - prev.y) * ratio
                };
            }, [currentTime, keyframes]);

            // Dragging Logic
            const handleTimelineMouseDown = (e, type = null) => {
                // Support Touch Events
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                
                if (type) {
                    e.stopPropagation();
                    draggingTrimRef.current = type;
                } else {
                    if (draggingKeyframeIdRef.current) return;
                    isDraggingRef.current = true;
                }
                handleTimelineMove(e);
            };
            
            const handleTimelineMove = (e) => {
                if (!timelineRef.current) return;
                
                const clientX = e.touches ? e.touches[0].clientX : e.clientX;
                const rect = timelineRef.current.getBoundingClientRect();
                const pos = Math.max(0, Math.min(1, (clientX - rect.left) / rect.width));
                const time = pos * duration;

                if (draggingTrimRef.current) {
                    setTrim(prev => {
                        let newTrim = { ...prev };
                        if (draggingTrimRef.current === 'start') {
                            newTrim.start = Math.min(time, prev.end - 0.5);
                        } else {
                            newTrim.end = Math.max(time, prev.start + 0.5);
                        }
                        return newTrim;
                    });
                } else if (draggingKeyframeIdRef.current) {
                    // Dragging keyframe
                    updateKeyframe(draggingKeyframeIdRef.current, { time });
                } else if (isDraggingRef.current) {
                    // Dragging playhead
                    if (videoRef.current) videoRef.current.currentTime = time;
                }
            };

            const handleTimelineMouseUp = () => {
                isDraggingRef.current = false;
                draggingKeyframeIdRef.current = null;
                draggingTrimRef.current = null;
            };

            useEffect(() => {
                window.addEventListener('mousemove', handleTimelineMove);
                window.addEventListener('mouseup', handleTimelineMouseUp);
                window.addEventListener('touchmove', handleTimelineMove, { passive: false });
                window.addEventListener('touchend', handleTimelineMouseUp);
                return () => {
                    window.removeEventListener('mousemove', handleTimelineMove);
                    window.removeEventListener('mouseup', handleTimelineMouseUp);
                    window.removeEventListener('touchmove', handleTimelineMove);
                    window.removeEventListener('touchend', handleTimelineMouseUp);
                };
            }, [duration, keyframes]);

            return (
                <div className="h-[calc(100vh-6rem)] flex flex-col gap-4 animate-fade-in">
                    {/* Top Bar */}
                    <div className="flex items-center justify-between bg-white px-6 py-3 rounded-xl border border-slate-200 shadow-sm shrink-0 dark:bg-slate-800 dark:border-slate-700">
                        <div className="flex items-center gap-4">
                            <Button variant="ghost" onClick={onBack} icon={ChevronLeft}>返回</Button>
                            <div className="h-6 w-px bg-slate-200 dark:bg-slate-700"></div>
                            <div className="flex flex-col">
                                <h2 className="font-bold text-slate-800 dark:text-white">{recording.title}</h2>
                                <span className="text-xs text-slate-500 font-mono dark:text-slate-400">{recording.slug}</span>
                            </div>
                        </div>
                        <div className="flex gap-2 items-center">
                            <HeaderControls theme={theme} toggleTheme={toggleTheme} />
                            <div className="w-px h-6 bg-slate-200 dark:bg-slate-700 mx-2"></div>
                             <div className="flex bg-slate-100 rounded-lg p-1 mr-4 dark:bg-slate-900">
                                <button onClick={() => setActiveTab('editor')} className={`px-3 py-1.5 rounded-md text-sm font-medium transition-all ${activeTab === 'editor' ? 'bg-white text-slate-900 shadow-sm dark:bg-slate-700 dark:text-white' : 'text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-200'}`}>视频编辑</button>
                                <button onClick={() => setActiveTab('notes')} className={`px-3 py-1.5 rounded-md text-sm font-medium transition-all ${activeTab === 'notes' ? 'bg-white text-slate-900 shadow-sm dark:bg-slate-700 dark:text-white' : 'text-slate-500 hover:text-slate-700 dark:text-slate-400 dark:hover:text-slate-200'}`}>备注文档</button>
                            </div>
                            <Button 
                                onClick={() => {
                                    setIsExporting(true);
                                    onExport({ trim, keyframes, duration, url: recording.url, setProgress: setExportProgress })
                                        .finally(() => setIsExporting(false));
                                }} 
                                disabled={isExporting} 
                                icon={Download}
                                className={isExporting ? "opacity-80 cursor-wait" : ""}
                            >
                                {isExporting ? `导出中 ${Math.round(exportProgress)}%` : '导出 MP4'}
                            </Button>
                        </div>
                    </div>

                    {activeTab === 'editor' ? (
                        <div className="flex-grow grid grid-cols-1 lg:grid-cols-3 gap-6 min-h-0">
                            {/* Main Preview Area */}
                            <div className="lg:col-span-2 flex flex-col gap-4 h-full min-h-0">
                                <div className="flex-grow bg-slate-950 rounded-xl overflow-hidden relative flex items-center justify-center border border-slate-800 shadow-inner group min-h-0">
                                    <video 
                                        ref={videoRef}
                                        src={recording.url}
                                        className="max-w-full max-h-full object-contain"
                                        style={{ transform: `scale(${currentTransform.scale}) translate(${currentTransform.x}%, ${currentTransform.y}%)`, transition: isPlaying ? 'none' : 'transform 0.1s' }}
                                        onLoadedMetadata={e => setDuration(e.target.duration)}
                                        onTimeUpdate={handleTimeUpdate}
                                        onEnded={() => setIsPlaying(false)}
                                    />
                                    <div className="absolute bottom-6 left-1/2 -translate-x-1/2 flex items-center gap-4 bg-slate-900/80 backdrop-blur text-white px-6 py-3 rounded-full opacity-0 group-hover:opacity-100 transition-opacity">
                                        <button onClick={togglePlay}><Icon icon={isPlaying ? Pause : Play} /></button>
                                        <span className="font-mono text-sm">{formatTime(currentTime)} / {formatTime(duration)}</span>
                                    </div>
                                </div>
                                
                                {/* Timeline */}
                                <div className="bg-white p-4 rounded-xl border border-slate-200 h-28 relative select-none shrink-0 dark:bg-slate-800 dark:border-slate-700"
                                     ref={timelineRef}
                                     onMouseDown={handleTimelineMouseDown}
                                     onTouchStart={handleTimelineMouseDown}
                                     >
                                    <div className="absolute inset-x-6 top-1/2 h-2 bg-slate-100 rounded-full overflow-visible dark:bg-slate-700">
                                        {/* Trim Masks */}
                                        <div className="absolute inset-y-0 left-0 bg-slate-300/50 z-10 rounded-l-full pointer-events-none dark:bg-slate-900/50" style={{ width: `${(trim.start/duration)*100}%` }}></div>
                                        <div className="absolute inset-y-0 right-0 bg-slate-300/50 z-10 rounded-r-full pointer-events-none dark:bg-slate-900/50" style={{ left: `${(trim.end/duration)*100}%` }}></div>

                                        {/* Trim Handles */}
                                        <div 
                                             className="absolute top-1/2 h-8 w-4 bg-white border border-slate-300 rounded-l-md cursor-ew-resize z-30 flex items-center justify-center group hover:border-blue-500 transition-colors dark:bg-slate-700 dark:border-slate-600"
                                             style={{ left: `${(trim.start/duration)*100}%`, transform: 'translate(-100%, -50%)' }}
                                             onMouseDown={(e) => handleTimelineMouseDown(e, 'start')}
                                             onTouchStart={(e) => handleTimelineMouseDown(e, 'start')}
                                             title={`开始: ${formatTime(trim.start)}`}
                                        >
                                            <div className="w-1 h-3 bg-slate-300 rounded-full group-hover:bg-blue-500 dark:bg-slate-500"></div>
                                        </div>
                                        <div 
                                             className="absolute top-1/2 h-8 w-4 bg-white border border-slate-300 rounded-r-md cursor-ew-resize z-30 flex items-center justify-center group hover:border-blue-500 transition-colors dark:bg-slate-700 dark:border-slate-600"
                                             style={{ left: `${(trim.end/duration)*100}%`, transform: 'translate(0, -50%)' }}
                                             onMouseDown={(e) => handleTimelineMouseDown(e, 'end')}
                                             onTouchStart={(e) => handleTimelineMouseDown(e, 'end')}
                                             title={`结束: ${formatTime(trim.end)}`}
                                        >
                                            <div className="w-1 h-3 bg-slate-300 rounded-full group-hover:bg-blue-500 dark:bg-slate-500"></div>
                                        </div>

                                        <div className="h-full bg-slate-900/10 rounded-full dark:bg-white/20" style={{ width: `${(currentTime/duration)*100}%` }}></div>
                                        
                                        {/* Playhead */}
                                        <div className="absolute top-1/2 w-4 h-4 bg-white border-2 border-red-500 rounded-full -translate-y-1/2 cursor-grab active:cursor-grabbing z-20" 
                                             style={{ left: `calc(${(currentTime/duration)*100}% - 8px)` }}>
                                             <div className="absolute top-full left-1/2 w-px h-8 bg-red-500/50 -translate-x-1/2 pointer-events-none"></div>
                                        </div>

                                        {/* Keyframe Dots */}
                                        {keyframes.map(kf => (
                                            <div key={kf.id} 
                                                 className={`absolute top-1/2 w-3 h-3 rounded-full -translate-y-1/2 -ml-1.5 cursor-pointer z-10 transition-transform hover:scale-150 ${selectedKeyframeId === kf.id ? 'bg-blue-600 ring-2 ring-blue-200 dark:ring-blue-900' : 'bg-blue-400'}`}
                                                 style={{ left: `${(kf.time/duration)*100}%` }}
                                                 onMouseDown={(e) => { 
                                                     e.stopPropagation(); 
                                                     setSelectedKeyframeId(kf.id); 
                                                     draggingKeyframeIdRef.current = kf.id;
                                                     videoRef.current.currentTime = kf.time; 
                                                 }}
                                                 onTouchStart={(e) => {
                                                     e.stopPropagation();
                                                     setSelectedKeyframeId(kf.id);
                                                     draggingKeyframeIdRef.current = kf.id;
                                                     videoRef.current.currentTime = kf.time;
                                                 }}
                                            />
                                        ))}
                                    </div>
                                    <div className="absolute bottom-2 left-6 right-6 flex justify-between text-[10px] text-slate-400 font-mono pointer-events-none">
                                        <span>00:00</span>
                                        <span>{formatTime(duration)}</span>
                                    </div>
                                </div>
                            </div>

                            {/* Properties Panel */}
                            <Card title="关键帧属性" className="h-full">
                                <div className="space-y-6">
                                    <Button onClick={addKeyframe} variant="secondary" className="w-full" icon={Plus}>在此处添加关键帧</Button>
                                    
                                    {selectedKeyframe ? (
                                        <div className="space-y-4 animate-fade-in bg-slate-50 p-4 rounded-lg border border-slate-100 dark:bg-slate-900 dark:border-slate-700">
                                            <div className="flex justify-between items-center">
                                                <span className="text-sm font-medium text-blue-600 dark:text-blue-400">时间点: {formatTime(selectedKeyframe.time)}</span>
                                                <button onClick={() => deleteKeyframe(selectedKeyframe.id)} className="text-red-500 hover:bg-red-50 p-1 rounded dark:hover:bg-red-900/20"><Icon icon={Trash2} size={16}/></button>
                                            </div>
                                            <div className="space-y-3">
                                                <div><label className="text-xs text-slate-500 dark:text-slate-400">缩放 (x{selectedKeyframe.scale.toFixed(1)})</label><input type="range" min="1" max="3" step="0.1" value={selectedKeyframe.scale} onChange={e => updateKeyframe(selectedKeyframe.id, {scale: parseFloat(e.target.value)})} className="w-full"/></div>
                                                <div><label className="text-xs text-slate-500 dark:text-slate-400">X 偏移</label><input type="range" min="-50" max="50" value={selectedKeyframe.x} onChange={e => updateKeyframe(selectedKeyframe.id, {x: parseFloat(e.target.value)})} className="w-full"/></div>
                                                <div><label className="text-xs text-slate-500 dark:text-slate-400">Y 偏移</label><input type="range" min="-50" max="50" value={selectedKeyframe.y} onChange={e => updateKeyframe(selectedKeyframe.id, {y: parseFloat(e.target.value)})} className="w-full"/></div>
                                            </div>
                                        </div>
                                    ) : (
                                        <div className="flex flex-col items-center justify-center py-10 text-slate-400">
                                            <Icon icon={Settings} size={32} className="mb-2 opacity-50"/>
                                            <p className="text-sm">选择或添加关键帧以编辑动画</p>
                                        </div>
                                    )}

                                    <div className="border-t border-slate-100 pt-4 dark:border-slate-700">
                                        <h4 className="text-xs font-bold text-slate-400 uppercase mb-3">关键帧列表</h4>
                                        <div className="space-y-1 max-h-[300px] overflow-y-auto pr-2">
                                            {keyframes.map(kf => (
                                                <div key={kf.id} onClick={() => { setSelectedKeyframeId(kf.id); if(videoRef.current) videoRef.current.currentTime = kf.time; }}
                                                     className={`flex items-center p-2 rounded-lg text-xs cursor-pointer transition-colors ${selectedKeyframeId === kf.id ? 'bg-slate-100 text-slate-900 font-bold border border-slate-200 dark:bg-slate-700 dark:text-white dark:border-slate-600' : 'text-slate-500 hover:bg-slate-50 border border-transparent dark:text-slate-400 dark:hover:bg-slate-800'}`}>
                                                    <span className="font-mono">{formatTime(kf.time)}</span>
                                                    <div className="ml-auto flex items-center gap-2">
                                                        <span className="bg-slate-200 px-1.5 rounded text-[10px] dark:bg-slate-700 dark:text-slate-300">x{kf.scale}</span>
                                                    </div>
                                                </div>
                                            ))}
                                            {keyframes.length === 0 && <div className="text-xs text-slate-300 text-center py-2">无关键帧</div>}
                                        </div>
                                    </div>
                                </div>
                            </Card>
                        </div>
                    ) : (
                        <div className="flex-grow bg-white rounded-xl border border-slate-200 shadow-sm overflow-hidden flex flex-col dark:bg-slate-800 dark:border-slate-700">
                             <ByteMDEditor value={markdown} onChange={setMarkdown} />
                        </div>
                    )}
                </div>
            );
        };

        const HeaderControls = ({ theme, toggleTheme }) => (
            <div className="flex items-center gap-2">
                <a href="https://github.com/sky22333/tools" target="_blank" className="p-2 text-slate-500 hover:text-slate-900 dark:text-slate-400 dark:hover:text-white transition-colors" title="GitHub">
                    <Icon icon={Github} size={20} />
                </a>
                <button onClick={toggleTheme} className="p-2 text-slate-500 hover:text-slate-900 dark:text-slate-400 dark:hover:text-white transition-colors" title={theme === 'dark' ? '切换亮色主题' : '切换暗色主题'}>
                    <Icon icon={theme === 'dark' ? Sun : Moon} size={20} />
                </button>
            </div>
        );

        const App = () => {
            const [view, setView] = useState('dashboard');
            const [isSetupOpen, setIsSetupOpen] = useState(false);
            const [isRecording, setIsRecording] = useState(false);
            const [isStarting, setIsStarting] = useState(false);
            const [theme, setTheme] = useState(() => {
                if (typeof window !== 'undefined') {
                    const saved = localStorage.getItem('theme');
                    if (saved) return saved;
                    if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) return 'dark';
                }
                return 'light';
            });

            useEffect(() => {
                if (theme === 'dark') {
                    document.documentElement.classList.add('dark');
                } else {
                    document.documentElement.classList.remove('dark');
                }
                localStorage.setItem('theme', theme);
            }, [theme]);

            const toggleTheme = () => setTheme(t => t === 'light' ? 'dark' : 'light');
            
            // Mock Data
            const [recordings, setRecordings] = useState([]);
            const [activeRecording, setActiveRecording] = useState(null);

            // Config State
            const [config, setConfig] = useState(() => {
                if (typeof window !== 'undefined') {
                    const saved = localStorage.getItem('recorder_config');
                    if (saved) {
                        try { return JSON.parse(saved); } catch (e) { console.error("Config parse error", e); }
                    }
                }
                return { micEnabled: true, systemAudioEnabled: true, micVolume: 1.0, resolution: '1080p', frameRate: '30' };
            });

            useEffect(() => {
                localStorage.setItem('recorder_config', JSON.stringify(config));
            }, [config]);

            // Recording Logic
            const mediaRecorderRef = useRef(null);
            const audioContextRef = useRef(null);
            const streamRef = useRef(null);
            const timerRef = useRef(null);
            const [recordingDuration, setRecordingDuration] = useState('00:00');

            const startRecording = async () => {
                if (isRecording || isStarting) return;
                setIsStarting(true);
                try {
                    const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
                    audioContextRef.current = audioCtx;
                    
                    const displayStream = await navigator.mediaDevices.getDisplayMedia({
                        video: { frameRate: parseInt(config.frameRate) },
                        audio: config.systemAudioEnabled
                    });
                    
                    displayStream.getVideoTracks()[0].onended = stopRecording;

                    const dest = audioCtx.createMediaStreamDestination();
                    const masterGain = audioCtx.createGain();
                    masterGain.connect(dest);

                    if (config.systemAudioEnabled && displayStream.getAudioTracks().length > 0) {
                        const sysSource = audioCtx.createMediaStreamSource(displayStream);
                        sysSource.connect(masterGain);
                    }

                    if (config.micEnabled) {
                        try {
                            const micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
                            const micSource = audioCtx.createMediaStreamSource(micStream);
                            const micGain = audioCtx.createGain();
                            micGain.gain.value = config.micVolume;
                            micSource.connect(micGain).connect(masterGain);
                            streamRef.current = new MediaStream([...displayStream.getTracks(), ...micStream.getTracks()]);
                        } catch (e) {
                            console.warn("Mic error", e);
                            streamRef.current = displayStream;
                        }
                    } else {
                        streamRef.current = displayStream;
                    }

                    const finalStream = new MediaStream([
                        ...displayStream.getVideoTracks(),
                        ...dest.stream.getAudioTracks()
                    ]);

                    const recorder = new MediaRecorder(finalStream, {
                        mimeType: MediaRecorder.isTypeSupported('video/webm;codecs=vp9') ? 'video/webm;codecs=vp9' : 'video/webm'
                    });

                    const chunks = [];
                    recorder.ondataavailable = e => { if (e.data.size > 0) chunks.push(e.data); };
                    recorder.onstop = () => {
                        const blob = new Blob(chunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const newRec = {
                            id: Date.now(),
                            title: `我的录屏 ${recordings.length + 1}`,
                            slug: `/recordings/untitled-${Date.now().toString().slice(-4)}`,
                            date: new Date().toLocaleDateString(),
                            duration: recordingDuration,
                            status: 'draft',
                            url: url,
                            blob: blob,
                            notes: ''
                        };
                        setRecordings(prev => [newRec, ...prev]);
                        setActiveRecording(newRec);
                        setIsRecording(false);
                        setIsSetupOpen(false);
                        setView('editor');
                        if (streamRef.current) streamRef.current.getTracks().forEach(t => t.stop());
                        if (audioContextRef.current) audioContextRef.current.close();
                        if (timerRef.current) clearInterval(timerRef.current);
                    };

                    recorder.start();
                    mediaRecorderRef.current = recorder;
                    setIsRecording(true);
                    setIsSetupOpen(false);
                    
                    const startTime = Date.now();
                    timerRef.current = setInterval(() => {
                        const diff = Math.floor((Date.now() - startTime) / 1000);
                        const m = Math.floor(diff / 60).toString().padStart(2, '0');
                        const s = (diff % 60).toString().padStart(2, '0');
                        setRecordingDuration(`${m}:${s}`);
                    }, 1000);

                } catch (err) {
                    console.error(err);
                    alert("启动录制失败: " + err.message);
                } finally {
                    setIsStarting(false);
                }
            };

            const stopRecording = () => {
                if (mediaRecorderRef.current && mediaRecorderRef.current.state !== 'inactive') {
                    mediaRecorderRef.current.stop();
                }
            };

            const handleExport = async ({ trim, keyframes, duration, url, setProgress }) => {
                if (!url) return;
                setProgress(0);
                
                try {
                    const video = document.createElement('video');
                    video.src = url;
                    video.muted = true;
                    await new Promise(r => { video.onloadedmetadata = r; });
                    
                    const audioCtx = new AudioContext();
                    const ab = await (await fetch(url)).arrayBuffer();
                    const audioBuffer = await audioCtx.decodeAudioData(ab);

                    const width = video.videoWidth % 2 === 0 ? video.videoWidth : video.videoWidth - 1;
                    const height = video.videoHeight % 2 === 0 ? video.videoHeight : video.videoHeight - 1;
                    
                    // --- Worker Code ---
                    const workerCode = `
                        importScripts("https://cdn.jsdelivr.net/npm/mp4-muxer@5.1.0/build/mp4-muxer.min.js");

                        let canvas, gl, muxer, videoEncoder, audioEncoder;
                        let writableStream = null;
                        let frameCounter = 0;

                        // Vertex Shader: Applies Scale and Translation
                        const vsSource = \`
                            attribute vec2 a_position;
                            attribute vec2 a_texCoord;
                            varying vec2 v_texCoord;
                            uniform vec2 u_scale;
                            uniform vec2 u_translation;
                            
                            void main() {
                                // Scale is around center (0,0), then translate
                                vec2 scaled = a_position * u_scale;
                                vec2 translated = scaled + u_translation;
                                gl_Position = vec4(translated, 0, 1);
                                v_texCoord = a_texCoord;
                            }
                        \`;

                        const fsSource = \`
                            precision mediump float;
                            varying vec2 v_texCoord;
                            uniform sampler2D u_texture;
                            
                            void main() {
                                gl_FragColor = texture2D(u_texture, v_texCoord);
                            }
                        \`;

                        function initWebGL(width, height) {
                            canvas = new OffscreenCanvas(width, height);
                            gl = canvas.getContext('webgl');
                            if (!gl) throw new Error("WebGL not supported in Worker");

                            // Create Shaders
                            const vs = gl.createShader(gl.VERTEX_SHADER);
                            gl.shaderSource(vs, vsSource);
                            gl.compileShader(vs);
                            if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(vs));

                            const fs = gl.createShader(gl.FRAGMENT_SHADER);
                            gl.shaderSource(fs, fsSource);
                            gl.compileShader(fs);
                            if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS)) throw new Error(gl.getShaderInfoLog(fs));

                            const program = gl.createProgram();
                            gl.attachShader(program, vs);
                            gl.attachShader(program, fs);
                            gl.linkProgram(program);
                            if (!gl.getProgramParameter(program, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(program));
                            gl.useProgram(program);

                            // Buffers
                            const positions = new Float32Array([
                                -1.0, -1.0,
                                 1.0, -1.0,
                                -1.0,  1.0,
                                 1.0,  1.0,
                            ]);
                            const texCoords = new Float32Array([
                                0.0, 1.0,
                                1.0, 1.0,
                                0.0, 0.0,
                                1.0, 0.0,
                            ]);

                            const pBuf = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, pBuf);
                            gl.bufferData(gl.ARRAY_BUFFER, positions, gl.STATIC_DRAW);
                            const aPos = gl.getAttribLocation(program, 'a_position');
                            gl.enableVertexAttribArray(aPos);
                            gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 0, 0);

                            const tBuf = gl.createBuffer();
                            gl.bindBuffer(gl.ARRAY_BUFFER, tBuf);
                            gl.bufferData(gl.ARRAY_BUFFER, texCoords, gl.STATIC_DRAW);
                            const aTex = gl.getAttribLocation(program, 'a_texCoord');
                            gl.enableVertexAttribArray(aTex);
                            gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, 0, 0);

                            // Texture
                            const texture = gl.createTexture();
                            gl.bindTexture(gl.TEXTURE_2D, texture);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
                            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);

                            return { program, texture };
                        }

                        self.onmessage = async (e) => {
                            const { type, data } = e.data;

                            if (type === 'init') {
                                try {
                                    const { width, height, fileHandle, audioConfig } = data;
                                    
                                    // 1. Setup Output Target (Streaming IO)
                                    let target;
                                    if (fileHandle) {
                                        writableStream = await fileHandle.createWritable();
                                        target = new Mp4Muxer.FileSystemWritableFileStreamTarget(writableStream);
                                    } else {
                                        // Fallback for mobile/unsupported: In-Memory
                                        target = new Mp4Muxer.ArrayBufferTarget();
                                    }

                                    // 2. Setup Muxer
                                    muxer = new Mp4Muxer.Muxer({
                                        target: target,
                                        video: { codec: 'avc', width, height },
                                        audio: { codec: 'aac', numberOfChannels: audioConfig.numberOfChannels, sampleRate: audioConfig.sampleRate },
                                        fastStart: fileHandle ? false : 'in-memory' // Fragmented/Streaming for disk, In-Memory for fallback
                                    });

                                    // 3. Setup Encoders
                                    videoEncoder = new VideoEncoder({
                                        output: (chunk, meta) => muxer.addVideoChunk(chunk, meta),
                                        error: e => self.postMessage({ type: 'error', message: e.message })
                                    });
                                    videoEncoder.configure({
                                        codec: 'avc1.4d0033',
                                        width, height,
                                        bitrate: 10_000_000,
                                        framerate: 30
                                    });

                                    audioEncoder = new AudioEncoder({
                                        output: (chunk, meta) => muxer.addAudioChunk(chunk, meta),
                                        error: e => self.postMessage({ type: 'error', message: e.message })
                                    });
                                    audioEncoder.configure({
                                        codec: 'mp4a.40.2', 
                                        numberOfChannels: audioConfig.numberOfChannels, 
                                        sampleRate: audioConfig.sampleRate, 
                                        bitrate: 128000
                                    });

                                    // 4. Setup WebGL
                                    self.webgl = initWebGL(width, height);
                                    self.width = width;
                                    self.height = height;

                                    self.postMessage({ type: 'ready' });

                                } catch (err) {
                                    self.postMessage({ type: 'error', message: err.message });
                                }
                            }

                            if (type === 'encode-audio') {
                                // Audio Streaming: Receive chunks of PCM data
                                const { planarData, format, sampleRate, numberOfFrames, timestamp } = data;
                                const audioData = new AudioData({
                                    format,
                                    sampleRate,
                                    numberOfFrames,
                                    numberOfChannels: planarData.length,
                                    timestamp,
                                    data: (() => {
                                        // Flatten planar data for AudioData (interleaved or planar depending on format)
                                        // WebCodecs AudioData usually expects one buffer.
                                        // For 'f32-planar', we concatenate the channels.
                                        const totalLen = planarData[0].length * planarData.length;
                                        const buffer = new Float32Array(totalLen);
                                        for (let i = 0; i < planarData.length; i++) {
                                            buffer.set(planarData[i], i * planarData[0].length);
                                        }
                                        return buffer;
                                    })()
                                });
                                audioEncoder.encode(audioData);
                                audioData.close();
                            }

                            if (type === 'encode-video') {
                                const { frame, transform, timestamp, keyFrame } = data;
                                
                                // GPU Acceleration: Render to OffscreenCanvas
                                const { program, texture } = self.webgl;
                                gl.activeTexture(gl.TEXTURE0);
                                gl.bindTexture(gl.TEXTURE_2D, texture);
                                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, frame);
                                
                                const uScale = gl.getUniformLocation(program, 'u_scale');
                                const uTrans = gl.getUniformLocation(program, 'u_translation');
                                
                                // Transform logic (scale, x, y are passed from main thread)
                                // UI x/y are percentages (-50 to 50). WebGL Clip Space is -1 to 1.
                                // Scale is 1.0 to 3.0.
                                gl.uniform2f(uScale, transform.scale, transform.scale);
                                gl.uniform2f(uTrans, transform.x / 50.0, -transform.y / 50.0); // Flip Y for WebGL
                                
                                gl.viewport(0, 0, self.width, self.height);
                                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);

                                // Create VideoFrame from Canvas
                                const newFrame = new VideoFrame(canvas, { timestamp });
                                videoEncoder.encode(newFrame, { keyFrame });
                                newFrame.close();
                                frame.close(); // Close original frame
                                
                                self.postMessage({ type: 'progress', value: 1 }); // Increment progress
                            }

                            if (type === 'flush') {
                                await videoEncoder.flush();
                                await audioEncoder.flush();
                                muxer.finalize();
                                
                                if (writableStream) {
                                    await writableStream.close();
                                }

                                videoEncoder.close();
                                audioEncoder.close();
                                
                                if (muxer.target instanceof Mp4Muxer.ArrayBufferTarget) {
                                    self.postMessage({ type: 'done', buffer: muxer.target.buffer });
                                } else {
                                    self.postMessage({ type: 'done' });
                                }
                            }
                        };
                    `;

                    // Create Worker
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    const worker = new Worker(URL.createObjectURL(blob));

                    // File System Access API (Streaming IO)
                    let fileHandle = null;
                    if ('showSaveFilePicker' in window) {
                        try {
                            fileHandle = await window.showSaveFilePicker({
                                suggestedName: `video-${Date.now()}.mp4`,
                                types: [{ description: 'MP4 Video', accept: { 'video/mp4': ['.mp4'] } }],
                            });
                        } catch (e) {
                            console.log("User cancelled or API not supported, falling back to in-memory");
                        }
                    }

                    // Init Worker
                    worker.postMessage({
                        type: 'init',
                        data: {
                            width, height,
                            fileHandle: fileHandle,
                            audioConfig: { numberOfChannels: audioBuffer.numberOfChannels, sampleRate: audioBuffer.sampleRate }
                        }
                    });

                    await new Promise((resolve, reject) => {
                        worker.onmessage = e => {
                            if (e.data.type === 'ready') resolve();
                            if (e.data.type === 'error') reject(new Error(e.data.message));
                        };
                    });

                    // --- Streaming Process ---
                    
                    // Audio Streaming (Chunk by Chunk)
                    const trimStart = trim?.start || 0;
                    const trimEnd = (trim?.end && trim.end > 0) ? trim.end : duration;
                    const exportDuration = Math.max(0, trimEnd - trimStart);
                    
                    const audioChunkSize = audioBuffer.sampleRate; // 1s chunks
                    const startSample = Math.floor(trimStart * audioBuffer.sampleRate);
                    const endSample = Math.floor(trimEnd * audioBuffer.sampleRate);
                    const totalSamples = endSample - startSample;

                    for (let i = 0; i < totalSamples; i += audioChunkSize) {
                        const size = Math.min(audioChunkSize, totalSamples - i);
                        const currentSampleIndex = startSample + i;
                        const planarData = [];
                        for (let ch = 0; ch < audioBuffer.numberOfChannels; ch++) {
                            const channelData = audioBuffer.getChannelData(ch);
                            const chunk = new Float32Array(size);
                            chunk.set(channelData.subarray(currentSampleIndex, currentSampleIndex + size));
                            planarData.push(chunk);
                        }
                        
                        worker.postMessage({
                            type: 'encode-audio',
                            data: {
                                planarData,
                                format: 'f32-planar',
                                sampleRate: audioBuffer.sampleRate,
                                numberOfFrames: size,
                                timestamp: (i / audioBuffer.sampleRate) * 1e6
                            }
                        }, planarData.map(f32 => f32.buffer)); // Transfer buffers
                    }

                    // Video Streaming (Frame by Frame)
                    const fps = 30;
                    const totalFrames = Math.floor(exportDuration * fps);
                    let processedFrames = 0;

                    worker.onmessage = e => {
                        if (e.data.type === 'progress') {
                            processedFrames++;
                            setProgress(Math.round((processedFrames / totalFrames) * 100));
                        }
                        if (e.data.type === 'done') {
                            if (e.data.buffer) {
                                // Fallback Download
                                const blob = new Blob([e.data.buffer], { type: 'video/mp4' });
                                const url = URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = `exported-video-${Date.now()}.mp4`;
                                a.click();
                            }
                            setProgress(100);
                            worker.terminate();
                        }
                        if (e.data.type === 'error') {
                            console.error("Worker Error:", e.data.message);
                            alert("导出出错: " + e.data.message);
                            worker.terminate();
                        }
                    };

                    for (let i = 0; i < totalFrames; i++) {
                        const timeRelativeToStart = i / fps;
                        const actualTime = trimStart + timeRelativeToStart;

                        video.currentTime = actualTime;
                        await new Promise(r => { 
                            const onSeek = () => { video.removeEventListener('seeked', onSeek); r(); };
                            video.addEventListener('seeked', onSeek);
                        });
                        
                        // Wait for frame to be ready (ensure repaint)
                        // Using createImageBitmap or new VideoFrame from video element
                        const frame = new VideoFrame(video, { timestamp: timeRelativeToStart * 1e6 });

                        // Calculate Transform
                        let scale = 1, x = 0, y = 0;
                        if (keyframes.length > 0) {
                             const sorted = keyframes;
                             let prev = sorted[0], next = sorted[sorted.length-1];
                             if (actualTime > sorted[0].time && actualTime < sorted[sorted.length-1].time) {
                                for(let k=0; k<sorted.length-1; k++) {
                                    if (actualTime >= sorted[k].time && actualTime < sorted[k+1].time) {
                                        prev = sorted[k]; next = sorted[k+1]; break;
                                    }
                                }
                             }
                             if (actualTime <= sorted[0].time) { prev=sorted[0]; next=sorted[0]; }
                             if (actualTime >= sorted[sorted.length-1].time) { prev=sorted[sorted.length-1]; next=sorted[sorted.length-1]; }

                             const ratio = (next.time === prev.time) ? 0 : (actualTime - prev.time) / (next.time - prev.time);
                             scale = prev.scale + (next.scale - prev.scale) * ratio;
                             x = prev.x + (next.x - prev.x) * ratio;
                             y = prev.y + (next.y - prev.y) * ratio;
                        }

                        worker.postMessage({
                            type: 'encode-video',
                            data: {
                                frame,
                                transform: { scale, x, y },
                                timestamp: timeRelativeToStart * 1e6,
                                keyFrame: i % 30 === 0
                            }
                        }, [frame]); // Transfer Frame

                        // Yield to main thread to prevent UI freezing
                        await new Promise(r => setTimeout(r, 0));
                    }

                    worker.postMessage({ type: 'flush' });

                } catch (err) {
                    console.error(err);
                    alert("导出失败: " + err.message);
                }
            };

            return (
                <div className="min-h-screen font-sans text-slate-900 bg-gray-50 selection:bg-slate-900 selection:text-white dark:bg-slate-900 dark:text-white">
                    {view === 'dashboard' && (
                        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
                            <div className="mb-8 flex flex-col md:flex-row md:items-center justify-between gap-4">
                                <div>
                                    <h1 className="text-2xl font-bold tracking-tight text-slate-900 dark:text-white">在线录屏工具</h1>
                                    <p className="text-slate-500 mt-1 dark:text-slate-400">管理和编辑您的所有录屏文件</p>
                                </div>
                                <HeaderControls theme={theme} toggleTheme={toggleTheme} />
                            </div>
                            <DashboardView 
                                recordings={recordings} 
                                onNewRecording={() => setIsSetupOpen(true)}
                                onEdit={(rec) => { setActiveRecording(rec); setView('editor'); }}
                                onDelete={(id) => setRecordings(prev => prev.filter(r => r.id !== id))}
                                onPreview={(rec) => { setActiveRecording(rec); setView('editor'); }}
                                isRecording={isRecording}
                            />
                        </div>
                    )}

                    {view === 'editor' && activeRecording && (
                        <div className="max-w-[1920px] mx-auto px-4 py-4 h-screen overflow-hidden">
                            <EditorView 
                                recording={activeRecording} 
                                onBack={() => { setView('dashboard'); setActiveRecording(null); }}
                                onSave={() => { setView('dashboard'); }}
                                onExport={handleExport}
                                theme={theme}
                                toggleTheme={toggleTheme}
                            />
                        </div>
                    )}

                    {/* Setup Modal */}
                    <Modal isOpen={isSetupOpen} onClose={() => setIsSetupOpen(false)} title="开始新的录制">
                        <div className="space-y-6">
                            <div className="space-y-4">
                                <Toggle label="启用麦克风" checked={config.micEnabled} onChange={v => setConfig({...config, micEnabled: v})} />
                                {config.micEnabled && (
                                    <div>
                                        <label className="text-xs font-semibold text-slate-500 uppercase mb-1 block">麦克风音量</label>
                                        <input type="range" min="0" max="2" step="0.1" value={config.micVolume} onChange={e => setConfig({...config, micVolume: parseFloat(e.target.value)})} className="w-full" />
                                    </div>
                                )}
                                <Toggle label="录制系统声音" checked={config.systemAudioEnabled} onChange={v => setConfig({...config, systemAudioEnabled: v})} />
                                <Select label="分辨率" value={config.resolution} onChange={v => setConfig({...config, resolution: v})} options={[
                                    {value: '1080p', label: '1080p (FHD)'},
                                    {value: '720p', label: '720p (HD)'},
                                    {value: '4k', label: '4k (UHD)'}
                                ]} />
                                 <Select label="帧率" value={config.frameRate} onChange={v => setConfig({...config, frameRate: v})} options={[
                                    {value: '30', label: '30 FPS'},
                                    {value: '60', label: '60 FPS'}
                                ]} />
                            </div>
                            
                            <div className="pt-4 flex justify-end gap-3">
                                <Button variant="ghost" onClick={() => setIsSetupOpen(false)} disabled={isStarting}>取消</Button>
                                <Button onClick={startRecording} icon={Video} className="bg-slate-900 text-white hover:bg-slate-800" disabled={isStarting}>
                                    {isStarting ? '启动中...' : '开始录制'}
                                </Button>
                            </div>
                        </div>
                    </Modal>

                    {/* Recording Overlay */}
                    {isRecording && (
                         <div className="fixed bottom-8 right-8 bg-slate-900 text-white p-4 rounded-2xl shadow-2xl flex items-center gap-6 animate-slide-up z-50 border border-slate-700">
                            <div className="flex items-center gap-3">
                                <div className="w-3 h-3 bg-red-500 rounded-full animate-pulse"></div>
                                <span className="font-mono font-medium text-lg">{recordingDuration}</span>
                            </div>
                            <div className="h-8 w-px bg-slate-700"></div>
                            <button onClick={stopRecording} className="bg-white text-slate-900 px-4 py-2 rounded-lg font-bold hover:bg-slate-100 transition-colors shadow-lg">
                                停止录制
                            </button>
                        </div>
                    )}
                </div>
            );
        };

        const root = ReactDOM.createRoot(document.getElementById('root'));
        root.render(<App />);
    </script>
</body>
</html>
